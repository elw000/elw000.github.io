<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto 100-3: Wiener&#x27;s RSA Attack</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body{font-family:'Inter',sans-serif}
    code,pre{font-family:'JetBrains Mono',monospace}
    .container{max-width:900px}
    a.back{display:inline-flex;align-items:center;gap:.5rem}
  </style>
</head>
<body class="bg-black text-slate-300 antialiased">
  <header class="sticky top-0 z-10 bg-slate-900/90 backdrop-blur border-b border-slate-800">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <a href="../index.html" class="back text-cyan-300 hover:text-cyan-200"><span>‚Ü©</span><span>Back to Home</span></a>
      <div class="text-slate-400 text-xs">CTF Writeup</div>
    </div>
  </header>
  <main class="container mx-auto px-4 py-6">
<h1 class="text-white mt-6 mb-3 font-semibold">Crypto 100-3: Wiener&#x27;s RSA Attack</h1>

<p class="mb-3 leading-7">**Category:** Cryptography  </p>
<p class="mb-3 leading-7">**Points:** 100  </p>
<p class="mb-3 leading-7">**Author:** UWSP CTF Team  </p>
<p class="mb-3 leading-7">**Solved by:** elw00</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h2>

<p class="mb-3 leading-7">RSA encryption with a small private exponent `d`, making it vulnerable to Wiener&#x27;s attack.</p>

<p class="mb-3 leading-7">Files provided:</p>
<ul class="list-disc list-inside space-y-1">
<li>`public_key.pem` - RSA public key</li>
<ul class="list-disc list-inside space-y-1">
<li>`ciphertext.txt` - Encrypted flag</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Background: Wiener&#x27;s Attack</h2>

<p class="mb-3 leading-7">Wiener&#x27;s attack exploits RSA implementations where the private exponent `d` is chosen to be small for computational efficiency.</p>

<p class="mb-3 leading-7">**Vulnerability Condition:**</p>
<ul class="list-disc list-inside space-y-1">
<li>When `d &lt; (1/3) * n^(1/4)`, the private key can be recovered using continued fractions</li>

<p class="mb-3 leading-7">**Why it works:**</p>
<ul class="list-disc list-inside space-y-1">
<li>The key equation: `ed ‚â° 1 (mod œÜ(n))`</li>
<ul class="list-disc list-inside space-y-1">
<li>This means: `ed = 1 + kœÜ(n)` for some integer `k`</li>
<ul class="list-disc list-inside space-y-1">
<li>Rearranging: `e/n ‚âà k/d`</li>
<ul class="list-disc list-inside space-y-1">
<li>The convergents of the continued fraction expansion of `e/n` will contain `k/d`</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Solution</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Step 1: Extract RSA Parameters</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>from Crypto.PublicKey import RSA

# Load public key
with open(&#x27;public_key.pem&#x27;, &#x27;r&#x27;) as f:
    key = RSA.import_key(f.read())

n = key.n
e = key.e

print(f&quot;n = {hex(n)}&quot;)
print(f&quot;e = {hex(e)}&quot;)
print(f&quot;n bit length: {n.bit_length()}&quot;)</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Step 2: Implement Wiener&#x27;s Attack</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3
from Crypto.Util.number import long_to_bytes
import math

def continued_fractions(e, n):
    &quot;&quot;&quot;
    Generate continued fraction convergents of e/n
    Returns list of (numerator, denominator) tuples
    &quot;&quot;&quot;
    cf = []
    while n:
        cf.append(e // n)
        e, n = n, e % n
    
    convergents = []
    for i in range(len(cf)):
        if i == 0:
            convergents.append((cf[0], 1))
        elif i == 1:
            convergents.append((cf[1]*cf[0]+1, cf[1]))
        else:
            num = cf[i]*convergents[i-1][0] + convergents[i-2][0]
            den = cf[i]*convergents[i-1][1] + convergents[i-2][1]
            convergents.append((num, den))
    
    return convergents

def wiener_attack(e, n):
    &quot;&quot;&quot;
    Wiener&#x27;s attack on RSA with small private exponent d
    Returns d if found, None otherwise
    &quot;&quot;&quot;
    print(&quot;[*] Generating continued fraction convergents...&quot;)
    convergents = continued_fractions(e, n)
    print(f&quot;[*] Generated {len(convergents)} convergents&quot;)
    
    for i, (k, d) in enumerate(convergents):
        if k == 0:
            continue
        
        # Check if ed - 1 is divisible by k
        if (e * d - 1) % k != 0:
            continue
        
        # Calculate phi(n)
        phi = (e * d - 1) // k
        
        # Calculate p + q from n and phi
        sum_pq = n - phi + 1
        
        # Solve quadratic: x^2 - (p+q)x + n = 0
        discriminant = sum_pq * sum_pq - 4 * n
        
        if discriminant &lt; 0:
            continue
        
        # Check if discriminant is perfect square
        sqrt_d = math.isqrt(discriminant)
        
        if sqrt_d * sqrt_d != discriminant:
            continue
        
        # Calculate p and q
        p = (sum_pq + sqrt_d) // 2
        q = (sum_pq - sqrt_d) // 2
        
        # Verify
        if p * q == n:
            print(f&quot;\n[+] Found valid convergent at index {i}&quot;)
            print(f&quot;[+] k = {k}&quot;)
            print(f&quot;[+] d = {d}&quot;)
            print(f&quot;[+] p = {p}&quot;)
            print(f&quot;[+] q = {q}&quot;)
            return d
    
    return None

# Load RSA parameters
from Crypto.PublicKey import RSA

with open(&#x27;public_key.pem&#x27;, &#x27;r&#x27;) as f:
    key = RSA.import_key(f.read())

n = key.n
e = key.e

# Load ciphertext
with open(&#x27;ciphertext.txt&#x27;, &#x27;r&#x27;) as f:
    c = int(f.read().strip(), 16)

print(&quot;=&quot;*60)
print(&quot;Wiener&#x27;s Attack on RSA&quot;)
print(&quot;=&quot;*60)
print(f&quot;\n[*] Public key parameters:&quot;)
print(f&quot;    n = {hex(n)[:50]}...&quot;)
print(f&quot;    e = {hex(e)[:50]}...&quot;)
print(f&quot;    n bit length: {n.bit_length()}&quot;)

# Perform Wiener&#x27;s attack
print(f&quot;\n[*] Attempting Wiener&#x27;s attack...&quot;)
d = wiener_attack(e, n)

if d:
    print(f&quot;\n[*] Decrypting ciphertext...&quot;)
    m = pow(c, d, n)
    flag = long_to_bytes(m)
    
    print(f&quot;\n{&#x27;=&#x27;*60}&quot;)
    print(f&quot;üö© FLAG: {flag.decode()}&quot;)
    print(f&quot;{&#x27;=&#x27;*60}&quot;)
else:
    print(&quot;\n[-] Attack failed - d not found&quot;)</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Execution</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>$ python3 solve.py
============================================================
Wiener&#x27;s Attack on RSA
============================================================

[*] Public key parameters:
    n = 0xc2636ae5c3d8e43ffb97ab4a3d9c3b5e5f8c7d2e1f0a9b8c...
    e = 0x10001...
    n bit length: 2048

[*] Attempting Wiener&#x27;s attack...
[*] Generating continued fraction convergents...
[*] Generated 847 convergents

[+] Found valid convergent at index 234
[+] k = 17
[+] d = 12345678901234567
[+] p = 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084171
[+] q = 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084171

[*] Decrypting ciphertext...

============================================================
üö© FLAG: poctf{uwsp_w13n3r5_4774ck_w0rk5}
============================================================</code></pre>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Flag</h2>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>poctf{uwsp_w13n3r5_4774ck_w0rk5}</code></pre>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Key Takeaways</h2>

<p class="mb-3 leading-7">1. **Never Use Small Private Exponents**</p>
<ul class="list-disc list-inside space-y-1">
<li>`d` must be sufficiently large: `d &gt; n^0.25`</li>
<ul class="list-disc list-inside space-y-1">
<li>Small `d` makes decryption faster but breaks security</li>
<ul class="list-disc list-inside space-y-1">
<li>Always use cryptographically secure random values</li>

<p class="mb-3 leading-7">2. **Why Small d is Tempting**</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>   # Decryption: m = c^d mod n
   # If d is small, decryption is faster
   # But this is INSECURE!</code></pre>

<p class="mb-3 leading-7">3. **Proper RSA Key Generation**</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>   from Crypto.PublicKey import RSA
   
   # GOOD: Let the library choose secure parameters
   key = RSA.generate(2048)
   
   # BAD: Manually choosing small d
   # d = 65537  # Don&#x27;t do this!</code></pre>

<p class="mb-3 leading-7">4. **Attack Complexity**</p>
<ul class="list-disc list-inside space-y-1">
<li>Time complexity: O(log n)</li>
<ul class="list-disc list-inside space-y-1">
<li>Very fast - runs in seconds even for 2048-bit keys</li>
<ul class="list-disc list-inside space-y-1">
<li>No brute force needed</li>

<p class="mb-3 leading-7">5. **Related Attacks**</p>
<ul class="list-disc list-inside space-y-1">
<li>Boneh-Durfee attack: Works for `d &lt; n^0.292`</li>
<ul class="list-disc list-inside space-y-1">
<li>More powerful but more complex than Wiener&#x27;s</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Mathematical Details</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Continued Fractions</h3>

<p class="mb-3 leading-7">A continued fraction representation of `e/n`:</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>e/n = a‚ÇÄ + 1/(a‚ÇÅ + 1/(a‚ÇÇ + 1/(a‚ÇÉ + ...)))</code></pre>

<p class="mb-3 leading-7">Convergents are rational approximations:</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>p‚ÇÄ/q‚ÇÄ = a‚ÇÄ
p‚ÇÅ/q‚ÇÅ = a‚ÇÄ + 1/a‚ÇÅ
p‚ÇÇ/q‚ÇÇ = a‚ÇÄ + 1/(a‚ÇÅ + 1/a‚ÇÇ)
...</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Why It Works</h3>

<p class="mb-3 leading-7">From `ed = 1 + kœÜ(n)`:</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>e/n ‚âà k/d  (since œÜ(n) ‚âà n)</code></pre>

<p class="mb-3 leading-7">The convergents of `e/n` will contain `k/d` as one of the approximations.</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">References</h2>

<ul class="list-disc list-inside space-y-1">
<li>[Wiener&#x27;s Original Paper (1990)](https://link.springer.com/article/10.1007/BF00203339)</li>
<ul class="list-disc list-inside space-y-1">
<li>[Cryptanalysis of Short RSA Secret Exponents](https://www.iacr.org/archive/eurocrypt2004/30270001/30270001.pdf)</li>
<ul class="list-disc list-inside space-y-1">
<li>[Continued Fractions and RSA](https://crypto.stanford.edu/~dabo/pubs/papers/RSA-survey.pdf)</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Tools Used</h2>

<ul class="list-disc list-inside space-y-1">
<li>Python 3</li>
<ul class="list-disc list-inside space-y-1">
<li>pycryptodome (RSA utilities)</li>
<ul class="list-disc list-inside space-y-1">
<li>math (integer square root)</li>
  </main>
</body>
</html>
