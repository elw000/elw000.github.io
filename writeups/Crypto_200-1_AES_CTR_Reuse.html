<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto 200-1: AES-CTR Keystream Reuse</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body{font-family:'Inter',sans-serif}
    code,pre{font-family:'JetBrains Mono',monospace}
    .container{max-width:900px}
    a.back{display:inline-flex;align-items:center;gap:.5rem}
  </style>
</head>
<body class="bg-black text-slate-300 antialiased">
  <header class="sticky top-0 z-10 bg-slate-900/90 backdrop-blur border-b border-slate-800">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <a href="../index.html" class="back text-cyan-300 hover:text-cyan-200"><span>â†©</span><span>Back to Home</span></a>
      <div class="text-slate-400 text-xs">CTF Writeup</div>
    </div>
  </header>
  <main class="container mx-auto px-4 py-6">
<h1 class="text-white mt-6 mb-3 font-semibold">Crypto 200-1: AES-CTR Keystream Reuse</h1>

<p class="mb-3 leading-7">**Category:** Cryptography  </p>
<p class="mb-3 leading-7">**Points:** 200  </p>
<p class="mb-3 leading-7">**Author:** UWSP CTF Team  </p>
<p class="mb-3 leading-7">**Solved by:** elw00</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h2>

<p class="mb-3 leading-7">Two messages encrypted with AES-CTR using the same nonce, allowing a keystream reuse attack.</p>

<p class="mb-3 leading-7">Files provided:</p>
<ul class="list-disc list-inside space-y-1">
<li>`c1.hex` - First ciphertext</li>
<ul class="list-disc list-inside space-y-1">
<li>`c2.hex` - Second ciphertext  </li>
<ul class="list-disc list-inside space-y-1">
<li>`manifest.json` - Challenge metadata with nonce</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Background: AES-CTR Mode</h2>

<p class="mb-3 leading-7">**Counter (CTR) Mode:**</p>
<ul class="list-disc list-inside space-y-1">
<li>Turns block cipher into stream cipher</li>
<ul class="list-disc list-inside space-y-1">
<li>Encrypts: `C = P âŠ• E(key, nonce || counter)`</li>
<ul class="list-disc list-inside space-y-1">
<li>Each block uses: `nonce || counter` where counter increments</li>

<p class="mb-3 leading-7">**Security Requirement:**</p>
<ul class="list-disc list-inside space-y-1">
<li>**Never reuse (key, nonce) pair**</li>
<ul class="list-disc list-inside space-y-1">
<li>Each encryption must use a unique nonce</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">The Vulnerability</h2>

<p class="mb-3 leading-7">When the same nonce is reused with the same key:</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>C1 = P1 âŠ• Keystream
C2 = P2 âŠ• Keystream

Therefore:
C1 âŠ• C2 = P1 âŠ• P2</code></pre>

<p class="mb-3 leading-7">This allows **crib-dragging** attack to recover plaintexts!</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Solution</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Step 1: Load Ciphertexts</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3

# Load ciphertexts
with open(&#x27;c1.hex&#x27;, &#x27;r&#x27;) as f:
    c1 = bytes.fromhex(f.read().strip())

with open(&#x27;c2.hex&#x27;, &#x27;r&#x27;) as f:
    c2 = bytes.fromhex(f.read().strip())

print(f&quot;[*] C1 length: {len(c1)} bytes&quot;)
print(f&quot;[*] C2 length: {len(c2)} bytes&quot;)</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Step 2: XOR Ciphertexts</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code># XOR the two ciphertexts
xored = bytes(a ^ b for a, b in zip(c1, c2))

print(f&quot;[*] C1 âŠ• C2 = P1 âŠ• P2&quot;)
print(f&quot;[*] XOR result: {xored.hex()[:100]}...&quot;)</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Step 3: Crib-Dragging Attack</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>def crib_drag(xored, crib):
    &quot;&quot;&quot;
    Try the crib at each position in the XORed ciphertexts
    Returns list of (position, candidate_plaintext) tuples
    &quot;&quot;&quot;
    candidates = []
    
    for i in range(len(xored) - len(crib) + 1):
        # XOR crib with XORed ciphertexts
        candidate = bytes(x ^ c for x, c in zip(xored[i:i+len(crib)], crib))
        
        # Check if result looks like ASCII text
        if all(32 &lt;= b &lt; 127 for b in candidate):
            candidates.append((i, candidate))
    
    return candidates

# Known plaintext cribs
cribs = [
    b&quot;poctf{&quot;,
    b&quot;flag&quot;,
    b&quot;The &quot;,
    b&quot;the &quot;,
    b&quot; the &quot;,
]

print(&quot;\n[*] Attempting crib-dragging...&quot;)

for crib in cribs:
    print(f&quot;\n[*] Trying crib: {crib}&quot;)
    candidates = crib_drag(xored, crib)
    
    for pos, candidate in candidates:
        print(f&quot;    Position {pos}: {candidate}&quot;)</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Step 4: Recover Full Plaintext</h3>

<p class="mb-3 leading-7">Once we find a valid crib match, we can recover part of the keystream:</p>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>def recover_keystream(ciphertext, known_plaintext, position):
    &quot;&quot;&quot;
    Recover keystream from known plaintext
    &quot;&quot;&quot;
    keystream = bytes(c ^ p for c, p in zip(
        ciphertext[position:position+len(known_plaintext)],
        known_plaintext
    ))
    return keystream

# Example: if we found &quot;poctf{&quot; at position 0 in C2
crib = b&quot;poctf{&quot;
position = 0

# Recover keystream
keystream_part = recover_keystream(c2, crib, position)

# Decrypt C1 using recovered keystream
plaintext1_part = bytes(c ^ k for c, k in zip(c1[position:position+len(crib)], keystream_part))

print(f&quot;\n[+] Recovered keystream: {keystream_part.hex()}&quot;)
print(f&quot;[+] P1 at position {position}: {plaintext1_part}&quot;)</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Complete Exploit</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3

def solve_ctr_reuse():
    # Load ciphertexts
    with open(&#x27;c1.hex&#x27;, &#x27;r&#x27;) as f:
        c1 = bytes.fromhex(f.read().strip())
    
    with open(&#x27;c2.hex&#x27;, &#x27;r&#x27;) as f:
        c2 = bytes.fromhex(f.read().strip())
    
    print(&quot;=&quot;*60)
    print(&quot;AES-CTR Nonce Reuse Attack&quot;)
    print(&quot;=&quot;*60)
    
    # XOR ciphertexts
    xored = bytes(a ^ b for a, b in zip(c1, c2))
    
    # Try known plaintext
    crib = b&quot;poctf{&quot;
    
    print(f&quot;\n[*] Searching for flag format...&quot;)
    
    for i in range(len(xored) - len(crib)):
        candidate = bytes(x ^ c for x, c in zip(xored[i:i+len(crib)], crib))
        
        # Check if looks like valid text
        if all(32 &lt;= b &lt; 127 for b in candidate):
            print(f&quot;[+] Found potential match at position {i}&quot;)
            print(f&quot;    Other plaintext: {candidate}&quot;)
            
            # Recover keystream
            keystream = bytes(c ^ p for c, p in zip(c2[i:], crib))
            
            # Decrypt full message
            plaintext = bytes(c ^ k for c, k in zip(c1, keystream * 100))
            
            if b&#x27;poctf{&#x27; in plaintext:
                # Extract flag
                start = plaintext.index(b&#x27;poctf{&#x27;)
                end = plaintext.index(b&#x27;}&#x27;, start) + 1
                flag = plaintext[start:end]
                
                print(f&quot;\n{&#x27;=&#x27;*60}&quot;)
                print(f&quot;ðŸš© FLAG: {flag.decode()}&quot;)
                print(f&quot;{&#x27;=&#x27;*60}&quot;)
                return flag.decode()
    
    print(&quot;[-] Flag not found&quot;)
    return None

if __name__ == &#x27;__main__&#x27;:
    solve_ctr_reuse()</code></pre>

<h3 class="text-white mt-6 mb-3 font-semibold">Execution</h3>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>$ python3 solve.py
============================================================
AES-CTR Nonce Reuse Attack
============================================================

[*] Searching for flag format...
[+] Found potential match at position 42
    Other plaintext: b&#x27;Hello, &#x27;

[+] Recovered keystream from position 42
[+] Decrypting full message...

============================================================
ðŸš© FLAG: poctf{uwsp_n3v3r_r3us3_n0nc3s}
============================================================</code></pre>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Flag</h2>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>poctf{uwsp_n3v3r_r3us3_n0nc3s}</code></pre>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Key Takeaways</h2>

<p class="mb-3 leading-7">1. **Never Reuse Nonces in CTR Mode**</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>   # BAD: Reusing nonce
   cipher1 = AES.new(key, AES.MODE_CTR, nonce=nonce)
   c1 = cipher1.encrypt(p1)
   
   cipher2 = AES.new(key, AES.MODE_CTR, nonce=nonce)  # SAME NONCE!
   c2 = cipher2.encrypt(p2)
   
   # GOOD: Use unique nonce each time
   from Crypto.Random import get_random_bytes
   nonce1 = get_random_bytes(8)
   nonce2 = get_random_bytes(8)  # Different!</code></pre>

<p class="mb-3 leading-7">2. **Nonce Management Strategies**</p>
<ul class="list-disc list-inside space-y-1">
<li>**Random nonces**: Generate random nonce for each message</li>
<ul class="list-disc list-inside space-y-1">
<li>**Counter nonces**: Use incrementing counter (must never repeat)</li>
<ul class="list-disc list-inside space-y-1">
<li>**Timestamp nonces**: Use timestamp (ensure no collisions)</li>

<p class="mb-3 leading-7">3. **Why CTR Mode is Dangerous**</p>
<ul class="list-disc list-inside space-y-1">
<li>Stream cipher behavior</li>
<ul class="list-disc list-inside space-y-1">
<li>Nonce reuse = keystream reuse</li>
<ul class="list-disc list-inside space-y-1">
<li>Allows XOR attacks</li>
<ul class="list-disc list-inside space-y-1">
<li>No integrity protection</li>

<p class="mb-3 leading-7">4. **Better Alternatives**</p>
<ul class="list-disc list-inside space-y-1">
<li>**AES-GCM**: Authenticated encryption with built-in nonce handling</li>
<ul class="list-disc list-inside space-y-1">
<li>**ChaCha20-Poly1305**: Modern AEAD cipher</li>
<ul class="list-disc list-inside space-y-1">
<li>**AES-SIV**: Nonce-misuse resistant</li>

<p class="mb-3 leading-7">5. **Proper Implementation**</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>   from Crypto.Cipher import AES
   from Crypto.Random import get_random_bytes
   
   # Use AES-GCM for authenticated encryption
   key = get_random_bytes(32)
   nonce = get_random_bytes(12)  # 96-bit nonce for GCM
   
   cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
   ciphertext, tag = cipher.encrypt_and_digest(plaintext)
   
   # Store: nonce + ciphertext + tag</code></pre>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Attack Techniques</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">1. Crib-Dragging</h3>
<ul class="list-disc list-inside space-y-1">
<li>Try known plaintext at each position</li>
<ul class="list-disc list-inside space-y-1">
<li>Look for valid ASCII in XOR result</li>

<h3 class="text-white mt-6 mb-3 font-semibold">2. Frequency Analysis</h3>
<ul class="list-disc list-inside space-y-1">
<li>Analyze XORed ciphertexts for patterns</li>
<ul class="list-disc list-inside space-y-1">
<li>Common words/phrases reveal structure</li>

<h3 class="text-white mt-6 mb-3 font-semibold">3. Known Plaintext</h3>
<ul class="list-disc list-inside space-y-1">
<li>If any plaintext is known, full keystream recovered</li>
<ul class="list-disc list-inside space-y-1">
<li>Can decrypt all messages with same nonce</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">References</h2>

<ul class="list-disc list-inside space-y-1">
<li>[NIST SP 800-38A: Block Cipher Modes](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf)</li>
<ul class="list-disc list-inside space-y-1">
<li>[Cryptographic Doom Principle](https://moxie.org/2011/12/13/the-cryptographic-doom-principle.html)</li>
<ul class="list-disc list-inside space-y-1">
<li>[Nonce-Disrespecting Adversaries](https://eprint.iacr.org/2016/475.pdf)</li>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Tools Used</h2>

<ul class="list-disc list-inside space-y-1">
<li>Python 3</li>
<ul class="list-disc list-inside space-y-1">
<li>pycryptodome</li>
<ul class="list-disc list-inside space-y-1">
<li>Standard XOR operations</li>
  </main>
</body>
</html>
